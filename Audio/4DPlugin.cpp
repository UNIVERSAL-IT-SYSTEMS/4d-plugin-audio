/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.c
 #	source generated by 4D Plugin Wizard
 #	Project : Audio
 #	author : miyako
 #	2013/11/02
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#include "AudioCapture.h"

#include <CoreServices/CoreServices.h>
#include <CoreAudio/CoreAudio.h>

//#include <CoreMedia/CoreMedia.h>//10.7
#import <QTKit/QTKit.h>//10.6

#import <AudioUnit/AudioUnit.h>
#import <AudioToolbox/AudioToolbox.h>

#include "AudioDeviceList.h"

AudioCapture *capture;

std::map<uint32_t, NSSound*> soundFileRefs;

// --- soundFileRefs

void _soundFileRefCreate(C_TEXT &path, C_LONGINT &index){
	
	unsigned int i = 0;
	
	NSURL *url = path.copyUrl();
	
	if(url){
		NSSound *sound = [[NSSound alloc]initWithContentsOfURL:url byReference:YES];
		[url release];
		i++;
		while (soundFileRefs.find(i) != soundFileRefs.end()) {
			i++;
		}
		soundFileRefs.insert(std::map<uint32_t, NSSound*>::value_type(i, sound));
		
	}
	
	index.setIntValue(i);
}

void _soundFileRefDelete(C_LONGINT &index){
	
	NSSound *sound = nil;
	
	std::map<uint32_t, NSSound*>::iterator pos = soundFileRefs.find(index.getIntValue());
	
	if(pos != soundFileRefs.end()) {
		sound = pos->second;
		[sound stop];
		[sound release];
		soundFileRefs.erase(pos);
	}
	
}

NSSound *_soundFileRefGet(C_LONGINT &index){
	
	NSSound *sound = nil;
	
	std::map<uint32_t, NSSound*>::iterator pos = soundFileRefs.find(index.getIntValue());
	
	if(pos != soundFileRefs.end()) {
		sound = pos->second;
	}
	
	return sound;
}

#pragma mark -

void PluginMain(int32_t selector, PA_PluginParameters params)
{
	try
	{
		int32_t pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		switch(pProcNum)
		{
			
			case 2 :				
			case 3 :	
			case 4 :					
				CommandDispatcherInMainProcess (pProcNum, params);
				break;
			default:
				CommandDispatcher(pProcNum, pResult, pParams);
				break;
		}

	}
	catch(...)
	{

	}
}

void CommandDispatcherInMainProcess (int32_t pProcNum, PA_PluginParameters params)
{
	switch(pProcNum)
	{
// --- Record			
		case 2 :
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)AUDIO_End_recording, params);		
			break;	
			
		case 3 :
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)AUDIO_Begin_recording, params);		
			break;	

		case 4 :
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)AUDIO_Is_recording, params);		
			break;				
	}
}

void CommandDispatcher (int32_t pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kDeinitPlugin:
		case kServerDeinitPlugin:
			if(capture) [capture release];
			break;
			
        case kInitPlugin:
		case kServerInitPlugin:
			capture = NULL;
			break;
			
// --- Devices

		case 1 :
			AUDIO_DEVICE_LIST(pResult, pParams);
			break;

			// --- Play
			
		case 5 :
			AUDIO_Open_file(pResult, pParams);
			break;
			
		case 6 :
			AUDIO_CLOSE(pResult, pParams);
			break;
			
		case 7 :
			AUDIO_PLAY(pResult, pParams);
			break;
			
		case 8 :
			AUDIO_PAUSE(pResult, pParams);
			break;
			
		case 9 :
			AUDIO_RESUME(pResult, pParams);
			break;
			
		case 10 :
			AUDIO_STOP(pResult, pParams);
			break;			
	}
}

// ------------------------------------ Devices -----------------------------------

void BuildDeviceList(AudioDeviceList *devlist, ARRAY_TEXT *names, ARRAY_LONGINT *ids)
{
	names->setSize(1);
	ids->setSize(1);
	
	AudioDeviceList::DeviceList &thelist = devlist->GetList();

	for (AudioDeviceList::DeviceList::iterator i = thelist.begin(); i != thelist.end(); ++i) {
		names->appendUTF8String((const uint8_t *)(*i).mName, strlen((*i).mName));
		ids->appendIntValue((*i).mID);
	}
}

void AUDIO_DEVICE_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT Param1;
	ARRAY_LONGINT Param2;
	C_LONGINT Param3;
	
	Param3.fromParamAtIndex(pParams, 3);
	
	AudioDeviceID audioDeviceId;
	
	bool isInput = (!Param3.getIntValue());
	
	AudioDeviceList *audioDeviceList = new AudioDeviceList(isInput);
	
	UInt32 propsize = sizeof(AudioDeviceID);
	AudioObjectPropertyAddress theAddress;

	theAddress.mSelector = isInput ? kAudioHardwarePropertyDefaultInputDevice : kAudioHardwarePropertyDefaultOutputDevice;
	theAddress.mScope = kAudioObjectPropertyScopeGlobal;
	theAddress.mElement = kAudioObjectPropertyElementMaster;	
		
    propsize = sizeof(AudioDeviceID);
	
	verify_noerr (AudioObjectGetPropertyData(kAudioObjectSystemObject,
											 &theAddress,
											 0,
											 NULL,
											 &propsize,
											 &audioDeviceId));
	
	BuildDeviceList(audioDeviceList, &Param1, &Param2);
	
	delete audioDeviceList;

	Param1.toParamAtIndex(pParams, 1);
	Param2.toParamAtIndex(pParams, 2);	
}

// ----------------------------------- Recording ----------------------------------

void AUDIO_End_recording(PA_PluginParameters params)
{
	sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
	
	C_TEXT returnValue;
	
	if (capture) {
		returnValue.setPath([capture outputFile]);
		[capture release];
		capture = NULL;	
	}
	
	returnValue.setReturn(pResult);	
}

void AUDIO_Is_recording(PA_PluginParameters params)
{
	sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
	
	C_LONGINT returnValue;
	
	if (capture) 
		returnValue.setIntValue([capture isRecording]);
	
	returnValue.setReturn(pResult);
}

void AUDIO_Begin_recording(PA_PluginParameters params)
{
	sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
	PackagePtr pParams = (PackagePtr)params->fParameters;
	
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	if(capture) [capture release];
	
	NSString *path = Param1.copyPath();
	
	capture = [[AudioCapture alloc]initWithPath:path];
	
	if([capture isRunning]){
		[capture setRecording:YES];
		returnValue.setIntValue(1);
	}
	
	[path release];
	
	returnValue.setReturn(pResult);
}

// ------------------------------------- Play -------------------------------------


void AUDIO_Open_file(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	_soundFileRefCreate(Param1,returnValue);
	
	returnValue.setReturn(pResult);
}

void AUDIO_CLOSE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	_soundFileRefDelete(Param1);	
}

void AUDIO_PLAY(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound) 
		[sound play];
}

void AUDIO_PAUSE(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound)
		[sound pause];
}

void AUDIO_RESUME(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound) 
		[sound resume];
}

void AUDIO_STOP(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	
	Param1.fromParamAtIndex(pParams, 1);
#if VERSIONWIN
#else	
	NSSound *sound = _soundFileRefGet(Param1);
	
	if(sound)
		[sound stop];
#endif	
}

